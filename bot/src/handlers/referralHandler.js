const User = require('../models/User');
const Plug = require('../models/Plug');
const Config = require('../models/Config');
const { ensureConnection } = require('../utils/database');
const { createMainKeyboard, createPlugKeyboard } = require('../utils/keyboards');
const { handlePlugDetails } = require('./plugsHandler');
const { getTranslation, translateDescription } = require('../utils/translations');

// Gestionnaire pour les liens de parrainage
const handleReferral = async (ctx, referralCode) => {
  try {
    console.log('üîó Traitement du parrainage avec code:', referralCode);
    
    await ensureConnection();
    
    const userId = ctx.from.id;
    const username = ctx.from.username;
    const firstName = ctx.from.first_name;
    const lastName = ctx.from.last_name;

    // V√©rifier si l'utilisateur existe d√©j√†
    // √âTAPE 1: D'abord trouver la boutique
    console.log('üîç Recherche boutique avec code:', referralCode);
    
    // Essayer d'abord par code exact
    let boutique = await Plug.findOne({ referralCode: referralCode });
    
    // Si pas trouv√©, extraire l'ID du code (format: ref_ID_timestamp)
    if (!boutique && referralCode.startsWith('ref_')) {
      const parts = referralCode.split('_');
      if (parts.length >= 2) {
        const boutiqueId = parts[1]; // L'ID est apr√®s "ref_"
        console.log('üîç Recherche par ID extrait:', boutiqueId);
        
        // V√©rifier si c'est un ID MongoDB valide
        if (boutiqueId.match(/^[a-f\d]{24}$/)) {
          boutique = await Plug.findById(boutiqueId);
        }
      }
    }
    
    if (!boutique) {
      console.log('‚ùå Code de parrainage invalide:', referralCode);
      console.log('‚ùå Aucune boutique trouv√©e pour ce code');
      return false;
    }

    console.log('‚úÖ Boutique trouv√©e:', boutique.name);

    // √âTAPE 2: V√©rifier l'utilisateur
    let user = await User.findOne({ telegramId: userId });
    
    if (user && user.invitedBy) {
      console.log('‚ö†Ô∏è Utilisateur d√©j√† parrain√© par:', user.invitedBy);
      console.log('üéØ Mais on va quand m√™me afficher la boutique demand√©e');
      // Utilisateur d√©j√† parrain√©, mais on affiche quand m√™me la boutique
      // Ne pas enregistrer de nouveau parrainage, juste rediriger
      await redirectToShopDetails(ctx, boutique);
      return true;
    }

    // Cr√©er ou mettre √† jour l'utilisateur
    if (!user) {
      user = new User({
        telegramId: userId,
        username: username,
        firstName: firstName,
        lastName: lastName
      });
    }

    // Associer l'utilisateur √† la boutique
    user.invitedBy = boutique._id; // ID de la boutique
    user.invitedAt = new Date();
    user.associatedShop = boutique._id;
    user.lastActivity = new Date();

    await user.save();

    // Ajouter l'utilisateur √† la liste des parrain√©s de la boutique
    console.log('üìù V√©rification utilisateur d√©j√† parrain√©...');
    const isAlreadyReferred = boutique.referredUsers.some(ref => ref.telegramId === userId);
    console.log(`üîç Utilisateur ${userId} d√©j√† dans la liste: ${isAlreadyReferred}`);
    
    if (!isAlreadyReferred) {
      console.log('‚ûï Ajout nouvel utilisateur parrain√©...');
      boutique.referredUsers.push({
        telegramId: userId,
        username: username,
        invitedAt: new Date()
      });
      boutique.totalReferred = boutique.referredUsers.length;
      console.log(`üìä Nouveau total parrain√©s: ${boutique.totalReferred}`);
      await boutique.save();
      console.log('‚úÖ Boutique sauvegard√©e avec nouveau parrain√©');
    } else {
      console.log('‚ö†Ô∏è Utilisateur d√©j√† parrain√©, pas d\'ajout');
    }

    console.log(`‚úÖ Parrainage r√©ussi: ${username} ‚Üí ${boutique.name}`);

    // Rediriger directement vers les d√©tails de la boutique
    console.log('üéØ Appel redirectToShopDetails...');
    await redirectToShopDetails(ctx, boutique);
    console.log('‚úÖ redirectToShopDetails termin√©');
    
    return true;

  } catch (error) {
    console.error('‚ùå Erreur dans handleReferral:', error);
    return false;
  }
};

// Rediriger directement vers les d√©tails de la boutique
const redirectToShopDetails = async (ctx, boutique) => {
  try {
    console.log(`üéØ D√âBUT redirectToShopDetails pour ${boutique.name}`);
    console.log('üîç Boutique ID:', boutique._id);
    console.log('üîç Boutique VIP:', boutique.isVip);
    
    // Afficher directement les d√©tails de la boutique avec bouton de retour appropri√©
    const { createPlugKeyboard } = require('../utils/keyboards');
    const { sendMessageWithImage } = require('../utils/messageHelper');
    
    const config = await Config.findById('main');
    const currentLang = config?.languages?.currentLanguage || 'fr';
    const customTranslations = config?.languages?.translations;

    let message = `${boutique.isVip ? '‚≠ê ' : ''}**${boutique.name}**\n\n`;
    const translatedDescription = translateDescription(boutique.description, currentLang);
    message += `${getTranslation('shop_description_label', currentLang, customTranslations)} ${translatedDescription}\n\n`;

    // Services disponibles avec formatage am√©lior√© et traductions
    const services = [];
    if (boutique.services?.delivery?.enabled) {
      const serviceName = getTranslation('service_delivery', currentLang, customTranslations);
      const serviceDesc = boutique.services.delivery.description ? 
        `: ${translateDescription(boutique.services.delivery.description, currentLang)}` : '';
      services.push(`üì¶ **${serviceName}**${serviceDesc}`);
    }
    if (boutique.services?.meetup?.enabled) {
      const serviceName = getTranslation('service_meetup', currentLang, customTranslations);
      const serviceDesc = boutique.services.meetup.description ? 
        `: ${translateDescription(boutique.services.meetup.description, currentLang)}` : '';
      services.push(`ü§ù **${serviceName}**${serviceDesc}`);
    }
    if (boutique.services?.postal?.enabled) {
      const serviceName = getTranslation('service_postal', currentLang, customTranslations);
      const serviceDesc = boutique.services.postal.description ? 
        `: ${translateDescription(boutique.services.postal.description, currentLang)}` : '';
      services.push(`üì¨ **${serviceName}**${serviceDesc}`);
    }

    if (services.length > 0) {
      const servicesTitle = getTranslation('services_available', currentLang, customTranslations);
      message += `**üîß ${servicesTitle} :**\n${services.join('\n')}\n\n`;
    }

    // Pays desservis
    if (boutique.countries && boutique.countries.length > 0) {
      message += `üåç **Pays desservis :** ${boutique.countries.join(', ')}\n\n`;
    }

    // Likes supprim√©s de la description - affich√©s uniquement sur le bouton

    // Cr√©er le clavier avec le contexte 'referral'
    const keyboard = createPlugKeyboard(boutique, 'referral', ctx.from?.id);

    console.log('üì§ Envoi du message de d√©tails...');
    console.log('üìù Message √† envoyer:', message.substring(0, 100) + '...');
    
    // Envoyer avec image si disponible
    if (boutique.image) {
      console.log('üñºÔ∏è Envoi avec image:', boutique.image);
      await ctx.replyWithPhoto(boutique.image, {
        caption: message,
        reply_markup: keyboard.reply_markup,
        parse_mode: 'Markdown'
      });
    } else {
      console.log('üìù Envoi sans image');
      await ctx.reply(message, {
        reply_markup: keyboard.reply_markup,
        parse_mode: 'Markdown'
      });
    }
    
    console.log(`‚úÖ FIN redirectToShopDetails - Message envoy√© pour ${boutique.name}`);

  } catch (error) {
    console.error('‚ùå Erreur redirection vers boutique:', error);
    
    // Fallback : message simple si la redirection √©choue
    try {
      const fallbackMessage = `üéâ **Bienvenue !**

Vous avez √©t√© invit√© par **${boutique.name}** !

Cliquez sur le bouton ci-dessous pour voir cette boutique :`;

      const keyboard = {
        inline_keyboard: [
          [{
            text: `üè™ Voir ${boutique.name}`,
            callback_data: `plug_${boutique._id}_from_referral`
          }],
          [{
            text: 'üåü Toutes les boutiques',
            callback_data: 'top_plugs'
          }]
        ]
      };

      await ctx.reply(fallbackMessage, {
        reply_markup: keyboard,
        parse_mode: 'Markdown'
      });
    } catch (fallbackError) {
      console.error('‚ùå Erreur fallback:', fallbackError);
    }
  }
};

// Commande /parrainage pour afficher les statistiques
const handleParrainageCommand = async (ctx) => {
  try {
    await ensureConnection();
    
    const userId = ctx.from.id;
    
    // 1. V√©rifier d'abord si l'utilisateur a une boutique avec ownerId
    let userShop = await Plug.findOne({ ownerId: userId });
    
    // 2. Si pas trouv√©, v√©rifier s'il a une demande approuv√©e
    if (!userShop) {
      const PlugApplication = require('../models/PlugApplication');
      const approvedApplication = await PlugApplication.findOne({ 
        userId: userId, 
        status: 'approved' 
      });
      
      if (approvedApplication) {
        // Chercher la boutique par nom (lien entre application et boutique)
        userShop = await Plug.findOne({ name: approvedApplication.name });
        
        // Si trouv√©e, associer l'utilisateur comme propri√©taire
        if (userShop && !userShop.ownerId) {
          userShop.ownerId = userId;
          await userShop.save();
          console.log(`‚úÖ Boutique ${userShop.name} associ√©e au propri√©taire ${userId}`);
        }
      }
    }

    if (!userShop) {
      return ctx.reply(`‚ùå **Aucune boutique trouv√©e**

Pour avoir acc√®s au syst√®me de parrainage, vous devez :
1Ô∏è‚É£ Avoir une demande de boutique approuv√©e
2Ô∏è‚É£ Votre boutique doit √™tre active

üí° Tapez /devenir pour faire une demande si ce n'est pas encore fait.`, { parse_mode: 'Markdown' });
    }

    // G√©n√©rer le lien si pas encore fait
    if (!userShop.referralCode || !userShop.referralLink) {
      const botInfo = await ctx.telegram.getMe();
      userShop.referralCode = userShop.generateReferralCode();
      userShop.referralLink = userShop.generateReferralLink(botInfo.username);
      await userShop.save();
    }

    // Informations d√©taill√©es sur les personnes invit√©es
    const referredUsers = userShop.referredUsers || [];
    const lastInvites = referredUsers.slice(-3); // Les 3 derni√®res personnes invit√©es
    
    let inviteDetails = '';
    if (lastInvites.length > 0) {
      inviteDetails = '\n\nüìã **Derni√®res personnes invit√©es:**\n';
      lastInvites.forEach((user, index) => {
        const date = new Date(user.invitedAt).toLocaleDateString('fr-FR');
        const username = user.username ? `@${user.username}` : `Utilisateur ${user.telegramId}`;
        inviteDetails += `${index + 1}. ${username} - ${date}\n`;
      });
      
      if (referredUsers.length > 3) {
        inviteDetails += `... et ${referredUsers.length - 3} autre${referredUsers.length - 3 > 1 ? 's' : ''}\n`;
      }
    }

    const message = `üîó **Votre lien de parrainage**

üè™ **${userShop.name}**
${userShop.isVip ? 'üëë **Boutique VIP**' : ''}

üìé \`${userShop.referralLink}\`

üìä **Statistiques compl√®tes:**
üë• Personnes invit√©es: **${userShop.totalReferred || 0}**
üëç Votes totaux: **${userShop.likes || 0}**
üìà Statut: **${userShop.isActive ? 'Actif ‚úÖ' : 'Inactif ‚ùå'}**${inviteDetails}

üí° **Comment √ßa marche ?**
‚Ä¢ Partagez votre lien sur Telegram, r√©seaux sociaux, etc.
‚Ä¢ Quand quelqu'un clique, il arrive directement sur votre boutique
‚Ä¢ Vous √™tes notifi√© de chaque nouvelle visite
‚Ä¢ Les statistiques se mettent √† jour en temps r√©el !`;

    await ctx.reply(message, { 
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{
            text: 'üìã Copier le lien',
            url: userShop.referralLink
          }],
          [{
            text: 'üëÅÔ∏è Voir ma boutique',
            callback_data: `plug_${userShop._id}`
          }],
          [{
            text: 'üìä Stats d√©taill√©es',
            callback_data: `referral_stats_${userShop._id}`
          }, {
            text: 'üîÑ Actualiser',
            callback_data: `refresh_referral_${userShop._id}`
          }]
        ]
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur dans handleParrainageCommand:', error);
    await ctx.reply('‚ùå Erreur lors de la r√©cup√©ration des informations de parrainage.');
  }
};

module.exports = {
  handleReferral,
  handleParrainageCommand,
  redirectToShopDetails
};
